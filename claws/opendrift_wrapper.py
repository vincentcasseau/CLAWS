#!/usr/bin/env python
"""Wrapper functions for OpenDrift 
"""

# Import modules
import numpy as np
from pyproj import Proj
import opendrift

from claws.claws import output_options

__author__ = "Vincent Casseau and Tom Scanlon"
__copyright__ = "Copyright 2022, MTS-CFD Ltd."
__credits__ = ["Vincent Casseau", "Tom Scanlon"]
__license__ = "GPLv2"
__version__ = "1.2"
__maintainer__ = "Vincent Casseau"
__email__ = "hystrath@gmail.com"
__status__ = "Production"


# ---------------------------------------------------------------------------- #
# Functions 
# ---------------------------------------------------------------------------- #

def get_histogram(outfile, pixelsize_m, corners=None, status=0, z0=0, dz=5,
                  marker_index=None, time_bin=None):
    """Return the multidimensional histogram that bins particles into voxels,
    irrespective of their seeding source
    
    Arguments:
        outfile: string; full path to the Opendrift .nc outfile
        
        pixelsize_m: float; size of the bins along the longitudinal and
            latitudinal directions, in meters
            
        corners: list of 4 floats: [lon_min, lon_max, lat_min, lat_max];   
            imposes the extent of the histogram. default is None, in which
            case the extent is defined as that of a bounding box containing
            all particles
            
        status: integer; status of the particles to consider. default is 0, that
            is active particles only. If status is None, all particles are
            considered irrespective of their status
            
        z0: float; elevation in meters at the top of the depth bin. default is 0
        
        dz: float; depth bin size in meters. default is 5
        
        marker_index: integer; marker index to identify different chemical
            substances. default: None (summing over all seeding sources)
        
        time_bin: integer; whether to create a histogram for a single time
            bin only. default is None (history preserved)
    """
    # Open the output file with Xarray.
    oa = opendrift.open_xarray(outfile)
    # Filter out particles according to their status and 
    #            particles whose depth is not in the range [z0-dz, z0] meters
    if status is None:
        oa.ds = oa.ds.where((oa.ds.z >= z0-dz) & (oa.ds.z <= z0))
    else:
        oa.ds = oa.ds.where((oa.ds.status == status) & (oa.ds.z >= z0-dz)
                                                     & (oa.ds.z <= z0))
    # Create histogram (binning time, longitude, latitude, and seeding source)
    if corners is None:
        h = oa.get_histogram(pixelsize_m=pixelsize_m)
    else:
        h = oa.get_histogram(pixelsize_m=pixelsize_m, corners=corners)  
    
    if marker_index is None:
        # Sum over all seeding sources
        h = h.sum(dim='origin_marker')
    else:
        # Return the concentration of a substance according to its marker index
        h = h.isel(origin_marker=marker_index)
    # Return histogram for a given time bin or for all time bins
    if time_bin is None:
        return h
    else:
        return h[time_bin]
    
def compute_concentration_domain(h):
    """Return the corners of the concentration domain. It does not necessarily
    match the dimensions of the user domain (depends on pixelsize_m).
        
    Arguments:
        h: Xarray; histogram as generated by Opendrift's get_histogram function
            from the data stored in the .nc outfile of the first ensemble
    """
    # Shift from cell centre values to node values
    lon_min = h.lon_bin[0].item()
    lat_min = h.lat_bin[0].item()
    lon_max = h.lon_bin[-1].item()
    lat_max = h.lat_bin[-1].item()
    dlon = h.lon_bin[1].item() - lon_min
    dlat = h.lat_bin[1].item() - lat_min
    return [lon_min-dlon/2., lon_max+dlon/2., lat_min-dlat/2., lat_max+dlat/2.]

def average_ensembles(h, nsimulations, outfile, pixelsize_m, corners, axis=None,
                      **kwargs):
    """Average all ensembles
    
    Arguments:
        h: Xarray; histogram as generated by Opendrift's get_histogram function
            from the data stored in the .nc outfile of the first ensemble
        
        nsimulations: integer; number of ensembles
        
        outfile: string; full path to the Opendrift .nc outfiles, minus
            their .nc extension
        
        pixelsize_m: float; size of the bins along the longitudinal and
                latitudinal directions, in meters
                
        corners: list of 4 floats: [lon_min, lon_max, lat_min, lat_max];   
                imposes the extent of the histogram. default is None, in which
                case the extent is defined as that of a bounding box containing
                all particles
                
        axis: tuple. axes along which to perform a summation (the rank of the 
            array will be decreased by len(axis)). default is None. Typically
            used for vertical dispersion where all longitudinal and latitudinal
            bin information are summed
        
        **kwargs:
            status: integer; status of the particles to consider. default is 0,
                that is active particles only. If status is None, all particles
                are considered irrespective of their status
                
            z0: float; elevation in meters at the top of the depth bin. default
                is 0
            
            dz: float; depth bin size in meters. default is 5
            
            marker_index: integer; marker index to identify different chemical
                substances. default: None (summing over all seeding sources)
            
            time_bin: integer; whether to create a histogram for a single time
                bin only. default is None (history preserved)
    """    
    # Cumulate over all ensembles
    for i in range(2, nsimulations + 1):
        of = outfile + '_' + str(i) + '.nc'
        hi = get_histogram(outfile=of, pixelsize_m=pixelsize_m, corners=corners,
                           **kwargs)
        if axis is not None:
            hi = hi.sum(axis=axis)
        h += hi
            
    # Average
    return h/float(nsimulations)
    
def get_series_probe(histo, lonbin, latbin):
    """Return the time series of the number of particles / concentration at a
    given position defined by its pair of longitudinal and latitudinal bin
    indices, uses Opendrift's pre-computed multidimensional histogram
    
    Arguments:
        histo: Xarray; histogram as generated by Opendrift get_histogram
            function from the data stored in the .nc outfile
        
        lonbin: integer; longitudinal bin index
        
        latbin: integer; latitudinal bin index
    """
    return histo[:,lonbin,latbin]
    
def get_series_peak_concentration(histo):
    """
    Return the time series of the maximum number of particles / peak
    concentration using Opendrift's pre-computed multidimensional histogram
    
    Arguments:
        histo: Xarray; histogram as generated by Opendrift get_histogram
            function from the data stored in the .nc outfile
    """
    return histo.max(axis=(1,2))
    
def get_series_area_over_limit(histo, pixelsize_m, limit=np.inf):
    """Return the time series of area where the concentration exceeds the
    Environmental Quality Standard (EQS). Uses Opendrift's pre-computed
    multidimensional histogram
    
    Arguments:
        histo: Xarray; histogram as generated by Opendrift get_histogram
            function from the data stored in the .nc outfile
        
        pixelsize_m: float; size of the bins along the longitudinal and
            latitudinal directions, in meters
        
        limit: float; Environmental Quality Standard (EQS) or Maximum Allowable
            Concentration (MAC) in ng/L. default is inf (i.e., not set)
    """
    # If the limit is not set, return a list of zeros
    if np.isinf(limit) or np.isnan(limit):
         ndt = np.shape(histo)[0]
         return np.zeros(shape=(ndt))
    # Nullify particle count in bins where the concentration is less than the
    # limit and set the particle count to 1 otherwise
    h = np.where(histo < limit, 0, 1)
    if len(np.shape(h)) == 3:
        # Sum over all longitudinal and latitudinal bins for each time sample
        # The value returned is the number of voxels in which the concentration
        # exceeds the EQS/MAC
        h = h.sum(axis=(1,2))
    else:
        # h is a sub-histogram (created for a unique time sample)
        # Sum over all longitudinal and latitudinal bins
        h = h.sum()
    # For each time sample, multiply the number of voxels in which the
    # concentration exceeds the EQS/MAC by the area of 1 pixel to get the total
    # area where the concentration exceeds the limit
    return h*pixelsize_m**2
    
def get_series_vertical_distribution(outfile, nsimulations, ndt,
    marker_index=None, status=0, nvbinsmax=10, maxdepth=10.):
    """Return the time series of the particle vertical distribution.
    
    Arguments:
        outfile: string; full path to the Opendrift .nc outfiles, minus
            their .nc extension
            
        nsimulations: integer; number of ensembles
        
        ndt: integer; number of time-steps
        
        marker_index: integer; marker index to identify different chemical
            substances. default: None (summing over all seeding sources)
        
        status: integer; status of the particles to consider. default is 0,
                that is active particles only. If status is None, all particles
                are considered irrespective of their status
        
        nvbinsmax: integer; maximum number of vertical bins. default is 10
                
        maxdepth: float; maximum depth in meters (positive or negative).
            default is 10.0 m below surface
    """
    # Initialisation
    if nsimulations > 1:
        of = outfile + '_1.nc'
    else:
        of = outfile + '.nc'
    vdist = np.zeros(shape=(0,ndt))
    no_particles_in_range = np.zeros(shape=(ndt))
    dz = abs(maxdepth)/float(nvbinsmax)
    axis = (1,2)
    
    # Total number of particles
    ntot = get_histogram(outfile=of, pixelsize_m=1e5, status=status, z0=0,
                         dz=1e5, marker_index=marker_index)
    # Sum over all longitudinal and latitudinal bins for each time step
    # The values returned are the total number of particles in the domain
    # This will later be used as a weight (normalisation)
    ntot = ntot.sum(axis=axis)
    # Average histogram values over all ensembles
    if nsimulations > 1:
        ntot = average_ensembles(h=ntot, nsimulations=nsimulations,
                                 outfile=outfile, pixelsize_m=1e5,
                                 corners=None, axis=axis, status=status, z0=0,
                                 dz=1e5, marker_index=marker_index)
    
    # Loop over all depth bins
    z0 = 0
    for vbin in range(nvbinsmax):
        try:
            # Get time series of the number of particles in the range [z0,z0-dz]
            vdist_vbin = get_histogram(outfile=of, pixelsize_m=1e5,
                                       status=status, z0=z0, dz=dz,
                                       marker_index=marker_index)
            vdist_vbin = vdist_vbin.sum(axis=axis)
        except ValueError:
            # This exception is raised when there aren't any particles in the
            # range. A new local maxdepth, zmax, is set (as opposed to the
            # 'blind' argument value of 'maxdepth')
            vdist_vbin = no_particles_in_range
            
        vdist = np.append(vdist, [vdist_vbin], axis=0)
        
        # Cumulate histogram values over all ensembles
        if nsimulations > 1:
            for i in range(2, nsimulations + 1):
                of = outfile + '_' + str(i) + '.nc'
                try:
                    vdisti = get_histogram(outfile=of, pixelsize_m=1e5,
                                           status=status, z0=z0, dz=dz,
                                           marker_index=marker_index)
                    vdisti = vdisti.sum(axis=axis)
                    vdist[-1] += vdisti
                except ValueError:
                    pass
                
        # Decrement the depth bin top surface height
        z0 -= dz
        
    # Average and normalise
    vdist = [v/(ntot*float(nsimulations)) for v in vdist]
    
    # Find maximum number of particle per layer at any time
    nmax = np.max(vdist)
    
    # Find last depth layer where at least one particle can be found
    zmax = -abs(maxdepth)
    nvbins = nvbinsmax
    for v in reversed(vdist):
        if np.shape(np.where(v == 0))[1] != ndt:
            break
        zmax += dz
        nvbins -= 1
    
    return [dz, round(zmax,2), nmax, vdist[:nvbins]]

def is_point_in_subhisto_bbox(pt, subh):
    """Determine if a point belongs inside the bounding box of a sub-histogram.
    """
    # Shorthands
    lon_min = subh.lon_bin[0].item()
    lat_min = subh.lat_bin[0].item()
    lon_mid = subh.lon_bin[1].item()
    lat_mid = subh.lat_bin[1].item()
    # Shift from cell centre values to node values
    dlon_bin = lon_mid - lon_min
    dlat_bin = lat_mid - lat_min
    dlon = 2.*dlon_bin
    dlat = 2.*dlat_bin
    lon_min -= dlon_bin/2.
    lat_min -= dlat_bin/2.
    lon_mid -= dlon_bin/2.
    lat_mid -= dlat_bin/2.
    
    if _is_point_in_rectangle(pt, (lon_min,lat_min), (dlon,dlat)):
        if _is_point_in_rectangle(pt, (lon_min,lat_min), (dlon_bin,dlat_bin)):  
            return subh[0,0].item()
        elif _is_point_in_rectangle(pt, (lon_min,lat_mid), (dlon_bin,dlat_bin)):  
            return subh[0,1].item()
        elif _is_point_in_rectangle(pt, (lon_mid,lat_mid), (dlon_bin,dlat_bin)):  
            return subh[1,1].item()
        elif _is_point_in_rectangle(pt, (lon_mid,lat_min), (dlon_bin,dlat_bin)):  
            return subh[1,0].item()
    return np.nan
    
def _is_point_in_rectangle(pt, blhc, dw):
    """
    Determine if a point belongs inside a rectangle using the point coordinates,
    the bottom left hand corner of the rectangle, blhc, and dw=(lengh,width)
    """
    if pt[0] < blhc[0] or pt[0] > blhc[0] + dw[0]: return False
    if pt[1] < blhc[1] or pt[1] > blhc[1] + dw[1]: return False
    return True
    
def get_alltime_min_max_concentrations(concentration, quadtree_conc_lvl,
                                       quadtree_obj):
    """Return all-time min and max concentrations obtained at 'time bins' and
    updates the peak concentration obtained over all histogram depth levels
    
    Arguments:
        concentration: list of Xarray histograms; as generated by Opendrift
            get_histogram function from the data stored in the .nc outfile and 
            the get_quadtree_histograms function
            
        quadtree_conc_lvl: nested python list; output of the
            get_quadtree_histograms function. Indicates the number of
            sub-histograms per output time bins and their depth level.
            
        quadtree_obj: Quadtree object as implemented in
            claws.Quadtree    
    """
    # Initialise variables
    len_time_bins = len(output_options["time_bins"])
    quadtree_peakconc = np.zeros(shape=(len_time_bins))
    offset = 1
    cminmin = np.inf
    cmaxmax = -np.inf
    
    # Loop over all time bins
    for i, tbin in enumerate(output_options["time_bins"]):
        # Root histogram min and max values
        conc = concentration[0][tbin].transpose()
        conc = conc.where(conc>0)
        cmin = conc.min().item()
        cmax = conc.max().item()

        # Sub-histograms search
        if quadtree_obj.is_active():
            for hi in np.arange(offset, offset + len(quadtree_conc_lvl[1+i])):
                conc = concentration[hi]
                conc = conc.where(conc>0)
                cmin = min(cmin, conc.min().item())
                cmax = max(cmax, conc.max().item())
                
            # Increment histogram offset
            offset += len(quadtree_conc_lvl[1+i])
        
        cminmin = min(cminmin, cmin)
        cmaxmax = max(cmaxmax, cmax)
        # Set sub-histogram peak concentration at time tbin
        quadtree_peakconc[i] = cmax
    return [cminmin, cmaxmax, quadtree_peakconc]    
